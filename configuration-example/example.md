# Configuration Examples

Below are some configuration examples, showing a sample `configuration.structure.yml` file and the 
resulting generated Java code from each.

## Example 1 - Connector for Acme Goods

Fictional scenario: Acme Corporation has a web preference with HTTP basic authentication, a proxy and a 
simple access token.  Their API uses a RESTful interface that supports pagination.  
They also have many custom configuration items specific to their business needs.

`configuration.structure.yml` file:

```
---
name: 'AcmeGoodsConnector'
configurationClass:
  name: 'AcmeGoodsConfiguration'
  package: 'com.acmegoods.connector.configuration'
rest: true
results: true
service: true
security:
  httpBasicAuth: true
  proxy: true
  authenticator:
    directAccessToken: true
custom:
  items:
    optional:
      numberOfDeparments:
        type: int
        default: 5
        display: 'Number of Departments'
        help: 'The number of Acme Good departments on site'
        validations:
          - '@Min(2)'
          - '@Max(100)'
      fulfillment:
        type: boolean
        display: 'Fulfillment'
        help: 'Does this office support fulfillment?'
      maximumNumberOfCustomers:
        type: long
        default: 125000000
      palletePrice:
        type: float
        default: 15.99
      locationAlias:
        type: string
        default: 'Unknown'
    required:
      secretWord:
        type: string
        confidential: true
      subdomainName:
        type: string
        default: 'unknown'
      superSecretWord:
        type: guarded_string
      shipToSates:
        display: 'Ship To States'
        help: 'List of states(abbreviations) this location will ship to'
        type: string_array
```

Java class generated from yml:

```
package com.acmegoods.connector.configuration;

import com.exclamationlabs.connid.base.connector.configuration.ConnectorConfiguration;
import com.exclamationlabs.connid.base.connector.configuration.ConfigurationInfo;
import com.exclamationlabs.connid.base.connector.configuration.ConfigurationReader;
import org.identityconnectors.framework.common.objects.ConnectorMessages;
import org.identityconnectors.framework.spi.ConfigurationClass;
import org.identityconnectors.framework.spi.ConfigurationProperty;
import org.identityconnectors.common.security.GuardedString;
import javax.validation.constraints.*;
import java.util.*;

import com.exclamationlabs.connid.base.connector.configuration.basetypes.RestConfiguration;
import com.exclamationlabs.connid.base.connector.configuration.basetypes.ResultsConfiguration;
import com.exclamationlabs.connid.base.connector.configuration.basetypes.ServiceConfiguration;
import com.exclamationlabs.connid.base.connector.configuration.basetypes.security.HttpBasicAuthConfiguration;
import com.exclamationlabs.connid.base.connector.configuration.basetypes.security.ProxyConfiguration;
import com.exclamationlabs.connid.base.connector.configuration.basetypes.security.authenticator.DirectAccessTokenConfiguration;

/**
* This class was automatically generated by connector-base-config-plugin.
* It is not ideal to modify this file, as subsequent builds of this project will overlay
* your changes in this file.  Instead, modify the configuration.structure.yml in this project.
*/
@ConfigurationClass(skipUnsupported = true, ignore={"active", "name", "source", "currentToken"})
public class AcmeGoodsConfiguration implements ConnectorConfiguration, RestConfiguration, ResultsConfiguration, ServiceConfiguration, HttpBasicAuthConfiguration, ProxyConfiguration, DirectAccessTokenConfiguration {

    protected ConnectorMessages connectorMessages;

    @ConfigurationInfo(path="source", internal=true)
    protected String source;

    @ConfigurationInfo(path="name", internal=true)
    protected String name;

    @ConfigurationInfo(path="active", internal=true)
    protected Boolean active;

    @ConfigurationInfo(path="currentToken", internal=true)
    protected String currentToken;

    @ConfigurationInfo(path="results.deepGet")
    private Boolean deepGet;

    @NotNull(message="shipToSates cannot be null")
    @ConfigurationInfo(path="custom.shipToSates")
    private String[] shipToSates;

    @ConfigurationInfo(path="results.pagination")
    private Boolean pagination;

    @ConfigurationInfo(path="custom.locationAlias")
    private String locationAlias = "Unknown";

    @Min(2)
    @Max(100)
    @ConfigurationInfo(path="custom.numberOfDeparments")
    private Integer numberOfDeparments = 5;

    @NotBlank
    @NotBlank(message="basicPassword cannot be blank")
    @ConfigurationInfo(path="security.httpBasicAuth.basicPassword")
    private String basicPassword;

    @NotBlank(message="secretWord cannot be blank")
    @ConfigurationInfo(path="custom.secretWord")
    private String secretWord;

    @NotBlank(message="serviceUrl cannot be blank")
    @ConfigurationInfo(path="service.serviceUrl")
    private String serviceUrl;

    @Pattern(regexp = "socks5|http", flags = Pattern.Flag.CASE_INSENSITIVE)
    @NotBlank(message="proxyType cannot be blank")
    @ConfigurationInfo(path="security.proxy.proxyType")
    private String proxyType;

    @ConfigurationInfo(path="results.importBatchSize")
    private Integer importBatchSize;

    @NotBlank
    @NotBlank(message="basicUsername cannot be blank")
    @ConfigurationInfo(path="security.httpBasicAuth.basicUsername")
    private String basicUsername;

    @NotNull(message="superSecretWord cannot be null")
    @ConfigurationInfo(path="custom.superSecretWord")
    private GuardedString superSecretWord;

    @NotBlank(message="proxyHost cannot be blank")
    @ConfigurationInfo(path="security.proxy.proxyHost")
    private String proxyHost;

    @NotBlank(message="token cannot be blank")
    @ConfigurationInfo(path="security.authenticator.directAccessToken.token")
    private String token;

    @NotNull(message="proxyPort cannot be null")
    @ConfigurationInfo(path="security.proxy.proxyPort")
    private Integer proxyPort;

    @ConfigurationInfo(path="service.duplicateErrorReturnsId")
    private Boolean duplicateErrorReturnsId = false;

    @Min(1)
    @Max(100)
    @ConfigurationInfo(path="rest.ioErrorRetries")
    private Integer ioErrorRetries = 5;

    @ConfigurationInfo(path="results.deepImport")
    private Boolean deepImport;

    @ConfigurationInfo(path="custom.fulfillment")
    private Boolean fulfillment;

    @ConfigurationInfo(path="custom.maximumNumberOfCustomers")
    private Long maximumNumberOfCustomers = 125000000L;

    @ConfigurationInfo(path="custom.palletePrice")
    private Float palletePrice = 15.99f;

    @NotBlank(message="subdomainName cannot be blank")
    @ConfigurationInfo(path="custom.subdomainName")
    private String subdomainName = "unknown";


    public AcmeGoodsConfiguration() {
        source = "default";
        name = "default";
        active = true;
    }

    public AcmeGoodsConfiguration(String configurationName) {
        name = configurationName;
        active = true;
        ConfigurationReader.prepareTestConfiguration(this);
    }

    @ConfigurationProperty(
    displayMessageKey = "Deep Get Enabled",
    helpMessageKey = "If true, an individual getOne request for each item in any getAll request will be performed.",
    confidential = false,
    required = false)
    public Boolean getDeepGet() {
        return this.deepGet;
    }

    public void setDeepGet(Boolean input) {
        this.deepGet = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "Ship To States",
    helpMessageKey = "List of states(abbreviations) this location will ship to",
    confidential = false,
    required = true)
    public String[] getShipToSates() {
        return this.shipToSates;
    }

    public void setShipToSates(String[] input) {
        this.shipToSates = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "Pagination Enabled",
    helpMessageKey = "Set to true if this connector (and its underlying API) supports pagination.",
    confidential = false,
    required = false)
    public Boolean getPagination() {
        return this.pagination;
    }

    public void setPagination(Boolean input) {
        this.pagination = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "custom.locationAlias.display",
    helpMessageKey = "custom.locationAlias.help",
    confidential = false,
    required = false)
    public String getLocationAlias() {
        return this.locationAlias;
    }

    public void setLocationAlias(String input) {
        this.locationAlias = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "Number of Departments",
    helpMessageKey = "The number of Acme Good departments on site",
    confidential = false,
    required = false)
    public Integer getNumberOfDeparments() {
        return this.numberOfDeparments;
    }

    public void setNumberOfDeparments(Integer input) {
        this.numberOfDeparments = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "HTTP Basic Auth Password",
    helpMessageKey = "HTTP Basic Authentication Password value",
    confidential = true,
    required = true)
    public String getBasicPassword() {
        return this.basicPassword;
    }

    public void setBasicPassword(String input) {
        this.basicPassword = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "custom.secretWord.display",
    helpMessageKey = "custom.secretWord.help",
    confidential = true,
    required = true)
    public String getSecretWord() {
        return this.secretWord;
    }

    public void setSecretWord(String input) {
        this.secretWord = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "Service URL",
    helpMessageKey = "The base service URL for the API this connector needs to access to get or store data.",
    confidential = false,
    required = true)
    public String getServiceUrl() {
        return this.serviceUrl;
    }

    public void setServiceUrl(String input) {
        this.serviceUrl = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "Proxy Type",
    helpMessageKey = "Type of Proxy Server - either `socks5` or `http`",
    confidential = false,
    required = true)
    public String getProxyType() {
        return this.proxyType;
    }

    public void setProxyType(String input) {
        this.proxyType = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "Import Batch Size",
    helpMessageKey = "If supplied, import operations will be invoked using this given batch size, so that API`s that support paging can import all records using a particular batch size (instead  of all at once.",
    confidential = false,
    required = false)
    public Integer getImportBatchSize() {
        return this.importBatchSize;
    }

    public void setImportBatchSize(Integer input) {
        this.importBatchSize = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "HTTP Basic Auth Username",
    helpMessageKey = "HTTP Basic Authentication Username value",
    confidential = false,
    required = true)
    public String getBasicUsername() {
        return this.basicUsername;
    }

    public void setBasicUsername(String input) {
        this.basicUsername = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "custom.superSecretWord.display",
    helpMessageKey = "custom.superSecretWord.help",
    confidential = false,
    required = true)
    public GuardedString getSuperSecretWord() {
        return this.superSecretWord;
    }

    public void setSuperSecretWord(GuardedString input) {
        this.superSecretWord = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "Proxy Host",
    helpMessageKey = "Domain or IP Address of Proxy Server",
    confidential = false,
    required = true)
    public String getProxyHost() {
        return this.proxyHost;
    }

    public void setProxyHost(String input) {
        this.proxyHost = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "Token",
    helpMessageKey = "Fixed token value providing access to the connector",
    confidential = true,
    required = true)
    public String getToken() {
        return this.token;
    }

    public void setToken(String input) {
        this.token = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "Proxy Port",
    helpMessageKey = "Port Number of Proxy Server",
    confidential = false,
    required = true)
    public Integer getProxyPort() {
        return this.proxyPort;
    }

    public void setProxyPort(Integer input) {
        this.proxyPort = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "Duplicate Error Returns Id",
    helpMessageKey = "When a create is attempted and an AlreadyExistsException is generated by the driver/invocator, the adapter shall attempt to call getOneByName() driver/invocator method to return the id of the existing record matching the current name value.",
    confidential = false,
    required = false)
    public Boolean getDuplicateErrorReturnsId() {
        return this.duplicateErrorReturnsId;
    }

    public void setDuplicateErrorReturnsId(Boolean input) {
        this.duplicateErrorReturnsId = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "IO Error Retries",
    helpMessageKey = "If IO Error occurs during API invocation, this number of retries will be attempted before giving up",
    confidential = false,
    required = false)
    public Integer getIoErrorRetries() {
        return this.ioErrorRetries;
    }

    public void setIoErrorRetries(Integer input) {
        this.ioErrorRetries = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "Deep Import Enabled",
    helpMessageKey = "If true, an individual getOne request for each item in Import getAll requests will be performed.",
    confidential = false,
    required = false)
    public Boolean getDeepImport() {
        return this.deepImport;
    }

    public void setDeepImport(Boolean input) {
        this.deepImport = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "Fulfillment",
    helpMessageKey = "Does this office support fulfillment?",
    confidential = false,
    required = false)
    public Boolean getFulfillment() {
        return this.fulfillment;
    }

    public void setFulfillment(Boolean input) {
        this.fulfillment = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "custom.maximumNumberOfCustomers.display",
    helpMessageKey = "custom.maximumNumberOfCustomers.help",
    confidential = false,
    required = false)
    public Long getMaximumNumberOfCustomers() {
        return this.maximumNumberOfCustomers;
    }

    public void setMaximumNumberOfCustomers(Long input) {
        this.maximumNumberOfCustomers = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "custom.palletePrice.display",
    helpMessageKey = "custom.palletePrice.help",
    confidential = false,
    required = false)
    public Float getPalletePrice() {
        return this.palletePrice;
    }

    public void setPalletePrice(Float input) {
        this.palletePrice = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "custom.subdomainName.display",
    helpMessageKey = "custom.subdomainName.help",
    confidential = false,
    required = true)
    public String getSubdomainName() {
        return this.subdomainName;
    }

    public void setSubdomainName(String input) {
        this.subdomainName = input;
    }


    @Override
    public ConnectorMessages getConnectorMessages() {
        return connectorMessages;
    }

    @Override
    public void setConnectorMessages(ConnectorMessages messages) {
        connectorMessages = messages;
    }

    @Override
    public String getCurrentToken() {
        return currentToken;
    }

    @Override
    public void setCurrentToken(String input) {
        currentToken = input;
    }

    @Override
    public String getSource() {
        return source;
    }

    @Override
    public void setSource(String input) {
        source = input;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public void setName(String input) {
        name = input;
    }

    @Override
    public Boolean getActive() {
        return active;
    }

    @Override
    public void setActive(Boolean input) {
        active = input;
    }


}
```

## Example 2 - Connector for Gotham Family Credit Union

Fictional scenario: As a financial institution, Gotham Family Credit Union requires higher security
and uses a PFX certificate OAuth2 client-credentials grant type for their security.  They also need
custom help text for some of their configuration items.

`configuration.structure.yml` file:

```
---
name: 'GothamFamilyCreditConnector'
configurationClass:
  name: 'GothamFamilyCreditConfiguration'
  package: 'com.gothamfcu.connid.base.connector.configuration'
rest: true
service: true
security:
  pfx: true
  authenticator:
    oauth2ClientCredentials: true
custom:
   helpText:
    serviceUrl:
      display: 'Gotham FCU API Service URL'
      help: 'Base URL used to connect to Gotham FCU service API'
    security:
      pfxFile:
        display: 'Gotham FCU Branch PFX File'
        help: 'PFX File for Gotham FCU Branch'
```

Java class generated from yml:

```
package com.gothamfcu.connid.base.connector.configuration;

import com.exclamationlabs.connid.base.connector.configuration.ConnectorConfiguration;
import com.exclamationlabs.connid.base.connector.configuration.ConfigurationInfo;
import com.exclamationlabs.connid.base.connector.configuration.ConfigurationReader;
import org.identityconnectors.framework.common.objects.ConnectorMessages;
import org.identityconnectors.framework.spi.ConfigurationClass;
import org.identityconnectors.framework.spi.ConfigurationProperty;
import org.identityconnectors.common.security.GuardedString;
import javax.validation.constraints.*;
import java.util.*;

import com.exclamationlabs.connid.base.connector.configuration.basetypes.RestConfiguration;
import com.exclamationlabs.connid.base.connector.configuration.basetypes.ServiceConfiguration;
import com.exclamationlabs.connid.base.connector.configuration.basetypes.security.PfxConfiguration;
import com.exclamationlabs.connid.base.connector.configuration.basetypes.security.authenticator.Oauth2ClientCredentialsConfiguration;

/**
* This class was automatically generated by connector-base-config-plugin.
* It is not ideal to modify this file, as subsequent builds of this project will overlay
* your changes in this file.  Instead, modify the configuration.structure.yml in this project.
*/
@ConfigurationClass(skipUnsupported = true, ignore={"active", "name", "source", "currentToken", "oauth2Information"})
public class GothamFamilyCreditConfiguration implements ConnectorConfiguration, RestConfiguration, ServiceConfiguration, PfxConfiguration, Oauth2ClientCredentialsConfiguration {

    protected ConnectorMessages connectorMessages;

    @ConfigurationInfo(path="source", internal=true)
    protected String source;

    @ConfigurationInfo(path="name", internal=true)
    protected String name;

    @ConfigurationInfo(path="active", internal=true)
    protected Boolean active;

    @ConfigurationInfo(path="currentToken", internal=true)
    protected String currentToken;

    @ConfigurationInfo(path="security.authenticator.oauth2ClientCredentials.oauth2Information", internal=true)
    private Map<String,String> oauth2Information;

    @ConfigurationInfo(path="service.duplicateErrorReturnsId")
    private Boolean duplicateErrorReturnsId = false;

    @Min(1)
    @Max(100)
    @ConfigurationInfo(path="rest.ioErrorRetries")
    private Integer ioErrorRetries = 5;

    @NotBlank(message="tokenUrl cannot be blank")
    @ConfigurationInfo(path="security.authenticator.oauth2ClientCredentials.tokenUrl")
    private String tokenUrl;

    @NotBlank(message="clientId cannot be blank")
    @ConfigurationInfo(path="security.authenticator.oauth2ClientCredentials.clientId")
    private String clientId;

    @NotNull(message="pfxPassword cannot be null")
    @ConfigurationInfo(path="security.pfx.pfxPassword")
    private GuardedString pfxPassword;

    @ConfigurationInfo(path="security.authenticator.oauth2ClientCredentials.scope")
    private String scope;

    @NotBlank(message="serviceUrl cannot be blank")
    @ConfigurationInfo(path="service.serviceUrl")
    private String serviceUrl;

    @NotBlank(message="pfxFile cannot be blank")
    @ConfigurationInfo(path="security.pfx.pfxFile")
    private String pfxFile;

    @NotNull(message="clientSecret cannot be null")
    @ConfigurationInfo(path="security.authenticator.oauth2ClientCredentials.clientSecret")
    private GuardedString clientSecret;


    public GothamFamilyCreditConfiguration() {
        source = "default";
        name = "default";
        active = true;
    }

    public GothamFamilyCreditConfiguration(String configurationName) {
        name = configurationName;
        active = true;
        ConfigurationReader.prepareTestConfiguration(this);
    }

    public Map<String,String> getOauth2Information() {
        return this.oauth2Information;
    }

    public void setOauth2Information(Map<String,String> input) {
        this.oauth2Information = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "Duplicate Error Returns Id",
    helpMessageKey = "When a create is attempted and an AlreadyExistsException is generated by the driver/invocator, the adapter shall attempt to call getOneByName() driver/invocator method to return the id of the existing record matching the current name value.",
    confidential = false,
    required = false)
    public Boolean getDuplicateErrorReturnsId() {
        return this.duplicateErrorReturnsId;
    }

    public void setDuplicateErrorReturnsId(Boolean input) {
        this.duplicateErrorReturnsId = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "IO Error Retries",
    helpMessageKey = "If IO Error occurs during API invocation, this number of retries will be attempted before giving up",
    confidential = false,
    required = false)
    public Integer getIoErrorRetries() {
        return this.ioErrorRetries;
    }

    public void setIoErrorRetries(Integer input) {
        this.ioErrorRetries = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "OAuth2 Token URL",
    helpMessageKey = "URL used to obtain OAuth2 token",
    confidential = false,
    required = true)
    public String getTokenUrl() {
        return this.tokenUrl;
    }

    public void setTokenUrl(String input) {
        this.tokenUrl = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "OAuth2 Client Id",
    helpMessageKey = "OAuth2 Client Id",
    confidential = true,
    required = true)
    public String getClientId() {
        return this.clientId;
    }

    public void setClientId(String input) {
        this.clientId = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "PFX Password",
    helpMessageKey = "Password value protecting the .pfx file",
    confidential = true,
    required = true)
    public GuardedString getPfxPassword() {
        return this.pfxPassword;
    }

    public void setPfxPassword(GuardedString input) {
        this.pfxPassword = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "OAuth2 Scope",
    helpMessageKey = "OAuth2 Scope (not used for some implementations)",
    confidential = false,
    required = false)
    public String getScope() {
        return this.scope;
    }

    public void setScope(String input) {
        this.scope = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "Service URL",
    helpMessageKey = "The base service URL for the API this connector needs to access to get or store data.",
    confidential = false,
    required = true)
    public String getServiceUrl() {
        return this.serviceUrl;
    }

    public void setServiceUrl(String input) {
        this.serviceUrl = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "PFX File",
    helpMessageKey = "Full file path to .pfx file",
    confidential = false,
    required = true)
    public String getPfxFile() {
        return this.pfxFile;
    }

    public void setPfxFile(String input) {
        this.pfxFile = input;
    }

    @ConfigurationProperty(
    displayMessageKey = "OAuth2 Client Secret",
    helpMessageKey = "OAuth2 Client Secret",
    confidential = true,
    required = true)
    public GuardedString getClientSecret() {
        return this.clientSecret;
    }

    public void setClientSecret(GuardedString input) {
        this.clientSecret = input;
    }


    @Override
    public ConnectorMessages getConnectorMessages() {
        return connectorMessages;
    }

    @Override
    public void setConnectorMessages(ConnectorMessages messages) {
        connectorMessages = messages;
    }

    @Override
    public String getCurrentToken() {
        return currentToken;
    }

    @Override
    public void setCurrentToken(String input) {
        currentToken = input;
    }

    @Override
    public String getSource() {
        return source;
    }

    @Override
    public void setSource(String input) {
        source = input;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public void setName(String input) {
        name = input;
    }

    @Override
    public Boolean getActive() {
        return active;
    }

    @Override
    public void setActive(Boolean input) {
        active = input;
    }


}
```


## Example 3 - Connector for Chester's Chess Club

Fictional scenario: Chester's Chess Club has a very simple web presence with no authentication or 
custom configuration items needed.

```
---
name: 'ChestersChessConnector'
configurationClass:
  name: 'ChestersChessConfiguration'
  package: 'com.chesterschess.connector.configuration'
```

Java class generated from yml:

```
package com.chesterschess.connector.configuration;

import com.exclamationlabs.connid.base.connector.configuration.ConnectorConfiguration;
import com.exclamationlabs.connid.base.connector.configuration.ConfigurationInfo;
import com.exclamationlabs.connid.base.connector.configuration.ConfigurationReader;
import org.identityconnectors.framework.common.objects.ConnectorMessages;
import org.identityconnectors.framework.spi.ConfigurationClass;
import org.identityconnectors.framework.spi.ConfigurationProperty;
import javax.validation.constraints.*;
import java.util.*;


/**
* This class was automatically generated by connector-base-config-plugin.
* It is not ideal to modify this file, as subsequent builds of this project will overlay
* your changes in this file.  Instead, modify the configuration.structure.yml in this project.
  */
  @ConfigurationClass(skipUnsupported = true, ignore={"active", "name", "source", "currentToken"})
  public class ChestersChessConfiguration implements ConnectorConfiguration {

  protected ConnectorMessages connectorMessages;

  @ConfigurationInfo(path="source", internal=true)
  protected String source;

  @ConfigurationInfo(path="name", internal=true)
  protected String name;

  @ConfigurationInfo(path="active", internal=true)
  protected Boolean active;

  @ConfigurationInfo(path="currentToken", internal=true)
  protected String currentToken;


    public ChestersChessConfiguration() {
        source = "default";
        name = "default";
        active = true;
    }

    public ChestersChessConfiguration(String configurationName) {
        name = configurationName;
        active = true;
        ConfigurationReader.prepareTestConfiguration(this);
    }


    @Override
    public ConnectorMessages getConnectorMessages() {
        return connectorMessages;
    }

    @Override
    public void setConnectorMessages(ConnectorMessages messages) {
        connectorMessages = messages;
    }

    @Override
    public String getCurrentToken() {
        return currentToken;
    }

    @Override
    public void setCurrentToken(String input) {
        currentToken = input;
    }

    @Override
    public String getSource() {
        return source;
    }

    @Override
    public void setSource(String input) {
        source = input;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public void setName(String input) {
        name = input;
    }

    @Override
    public Boolean getActive() {
        return active;
    }

    @Override
    public void setActive(Boolean input) {
        active = input;
    }


}
```
